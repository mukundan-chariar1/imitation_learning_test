# Imitation learning using brax and torch

## Notes

Attributes of state for generalized
- root_com: (num_links,) center of mass position of link root kinematic tree
- cinr: (num_links,) inertia in com frame
- cd: (num_links,) link velocities in com frame
- cdof: (qd_size,) dofs in com frame
- cdofd: (qd_size,) cdof velocity
- mass_mx: (qd_size, qd_size) mass matrix
- mass_mx_inv: (qd_size, qd_size) inverse mass matrix
- contact: calculated contacts
- con_jac: constraint jacobian
- con_diag: constraint A diagonal
- con_aref: constraint reference acceleration
- qf_smooth: (qd_size,) smooth dynamics force
- qf_constraint: (qd_size,) force from constraints (collision etc)
- qdd: (qd_size,) joint acceleration vector

Attributes of state in general
- q: (q_size,) joint position vector
- qd: (qd_size,) joint velocity vector
- x: (num_links,) link position in world frame
- xd: (num_links,) link velocity in world frame
- contact: calculated contacts

link names for base humanoid:
- 'torso', 
- 'lwaist', 
- 'pelvis', 
- 'right_thigh', 
- 'right_shin', 
- 'left_thigh', 
- 'left_shin', 
- 'right_upper_arm', 
- 'right_lower_arm', 
- 'left_upper_arm', 
- 'left_lower_arm'


Describes a physical environment: its links, joints and geometries.

- Attributes:
    - gravity: (3,) linear universal force applied during forward dynamics
    - viscosity: (1,) viscosity of the medium applied to all links
    - density: (1,) density of the medium applied to all links
    - link: (num_link,) the links in the system
    - dof: (qd_size,) every degree of freedom for the system
    - actuator: actuators that can be applied to links
    - init_q: (q_size,) initial q position for the system
    - elasticity: bounce/restitution encountered when hitting another geometry
    - vel_damping: (1,) linear vel damping applied to each body.
    - ang_damping: (1,) angular vel damping applied to each body.
    - baumgarte_erp: how aggressively interpenetrating bodies should push away\
                from one another
    - spring_mass_scale: a float that scales mass as `mass^(1 - x)`
    - spring_inertia_scale: a float that scales inertia diag as `inertia^(1 - x)`
    - joint_scale_ang: scale for position-based joint rotation update
    - joint_scale_pos: scale for position-based joint position update
    - collide_scale: fraction of position based collide update to apply
    - enable_fluid: (1,) enables or disables fluid forces based on the
      default viscosity and density parameters provided in the XML
    - link_names: (num_link,) link names
    - link_types: (num_link,) string specifying the joint type of each link
                valid types are:
                * 'f': free, full 6 dof (position + rotation), no parent link
                * '1': revolute,  1 dof, like a hinge
                * '2': universal, 2 dof, like a drive shaft joint
                * '3': spherical, 3 dof, like a ball joint
    - link_parents: (num_link,) int list specifying the index of each link's
                  parent link, or -1 if the link has no parent
    - matrix_inv_iterations: maximum number of iterations of the matrix inverse
    - solver_iterations: maximum number of iterations of the constraint solver
    - solver_maxls: maximum number of line searches of the constraint solver
    - mj_model: mujoco.MjModel that was used to build this brax System


['Pelvis', 'L_Hip', 'L_Knee', 'L_Ankle', 'L_Toe', 'R_Hip', 'R_Knee', 'R_Ankle', 'R_Toe', 'Torso', 'Spine', 'Chest', 'Neck', 'Head', 'L_Thorax', 'L_Shoulder', 'L_Elbow', 'L_Wrist', 'L_Hand', 'R_Thorax', 'R_Shoulder', 'R_Elbow', 'R_Wrist', 'R_Hand']

 """PPO training.

  Args:
    environment: the environment to train
    num_timesteps: the total number of environment steps to use during training
    episode_length: the length of an environment episode
    wrap_env: If True, wrap the environment for training. Otherwise use the
      environment as is.
    action_repeat: the number of timesteps to repeat an action
    num_envs: the number of parallel environments to use for rollouts
      NOTE: `num_envs` must be divisible by the total number of chips since each
        chip gets `num_envs // total_number_of_chips` environments to roll out
      NOTE: `batch_size * num_minibatches` must be divisible by `num_envs` since
        data generated by `num_envs` parallel envs gets used for gradient
        updates over `num_minibatches` of data, where each minibatch has a
        leading dimension of `batch_size`
    max_devices_per_host: maximum number of chips to use per host process
    num_eval_envs: the number of envs to use for evluation. Each env will run 1
      episode, and all envs run in parallel during eval.
    learning_rate: learning rate for ppo loss
    entropy_cost: entropy reward for ppo loss, higher values increase entropy of
      the policy
    discounting: discounting rate
    seed: random seed
    unroll_length: the number of timesteps to unroll in each environment. The
      PPO loss is computed over `unroll_length` timesteps
    batch_size: the batch size for each minibatch SGD step
    num_minibatches: the number of times to run the SGD step, each with a
      different minibatch with leading dimension of `batch_size`
    num_updates_per_batch: the number of times to run the gradient update over
      all minibatches before doing a new environment rollout
    num_evals: the number of evals to run during the entire training run.
      Increasing the number of evals increases total training time
    num_resets_per_eval: the number of environment resets to run between each
      eval. The environment resets occur on the host
    normalize_observations: whether to normalize observations
    reward_scaling: float scaling for reward
    clipping_epsilon: clipping epsilon for PPO loss
    gae_lambda: General advantage estimation lambda
    deterministic_eval: whether to run the eval with a deterministic policy
    network_factory: function that generates networks for policy and value
      functions
    progress_fn: a user-defined callback function for reporting/plotting metrics
    normalize_advantage: whether to normalize advantage estimate
    eval_env: an optional environment for eval only, defaults to `environment`
    policy_params_fn: a user-defined callback function that can be used for
      saving policy checkpoints
    randomization_fn: a user-defined callback function that generates randomized
      environments
    restore_checkpoint_path: the path used to restore previous model params
    max_grad_norm: gradient clipping norm value. If None, no clipping is done

  Returns:
    Tuple of (make_policy function, network params, metrics)
  """
solo indexes according to names: [9, 12, 11, 10, 13, 0]
left indexes according to names: [2, 15, 16, 1, 4, 3, 17, 18, 14]
right indexes according to names: [6, 20, 21, 5, 8, 7, 22, 23, 19]

['Pelvis', 'L_Hip', 'L_Knee', 'L_Ankle', 'L_Toe', 'R_Hip', 'R_Knee', 'R_Ankle', 'R_Toe', 'Torso', 'Spine', 'Chest', 'Neck', 'Head', 'L_Thorax', 'L_Shoulder', 'L_Elbow', 'L_Wrist', 'L_Hand', 'R_Thorax', 'R_Shoulder', 'R_Elbow', 'R_Wrist', 'R_Hand']

# Joints
pelvis: 0 change according to height
l hip (1) = r hip (5)= +ve
l knee (2) = r knee (6) = +ve
l ankle (3) = r ankle (7) = +ve
l toe (4) = r toe (8) = +ve

torso (9) = +ve
spine (10) = +ve
chest (11) = +ve
neck (12) = +ve
head (13) = +ve

l thorax (14) = -ve r thorax (19)= -ve
l shoulder (15) = -ve r shoulder (20)= -ve
l elbow (16) = -ve r elbow (21)= -ve
l wrist (17) = -ve r wrist (22)= -ve
l hand (18) = -ve r hand (23)= -ve

# Geoms

pelvis: (1) sphere
l hip (2) = r hip (6)= capsule (sphere+cylinder)
l knee (3) = r knee (7) = capsule (sphere+cylinder)
l ankle (4) = r ankle (8) = box
l toe (5) = r toe (9) = box

torso (10) = capsule (sphere+cylinder)
spine (11) = capsule (sphere+cylinder)
chest (12) = capsule (sphere+cylinder)
neck (13) = capsule (sphere+cylinder)
head (14) = sphere

l thorax (15) = -ve r thorax (20)= capsule (sphere+cylinder)
l shoulder (16) = -ve r shoulder (21)= capsule (sphere+cylinder)
l elbow (17) = -ve r elbow (22)= capsule (sphere+cylinder)
l wrist (18) = -ve r wrist (23)= capsule (sphere+cylinder)
l hand (19) = -ve r hand (24)= sphere




custom in mjcf={'ang_damping': array(-0.05), 'baumgarte_erp': array(0.1), 'collide_scale': array(1.), 'constraint_ang_damping': array([30., 30., 30., 30., 30., 30., 30., 30., 30., 30., 30., 30., 30.,
       30., 30., 30., 30., 30., 30., 30., 30., 30., 30., 30., 30.]), 'constraint_limit_stiffness': array([2500., 2500., 2500., 2500., 2500., 2500., 2500., 2500., 2500.,
       2500., 2500., 2500., 2500., 2500., 2500., 2500., 2500., 2500.,
       2500., 2500., 2500., 2500., 2500., 2500., 2500.]), 'constraint_stiffness': array([27000., 27000., 27000., 27000., 27000., 27000., 27000., 27000.,
       27000., 27000., 27000., 27000., 27000., 27000., 27000., 27000.,
       27000., 27000., 27000., 27000., 27000., 27000., 27000., 27000.,
       27000.]), 'constraint_vel_damping': array([80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80.,
       80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80.]), 'elasticity': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0.]), 'joint_scale_ang': array(0.1), 'joint_scale_pos': array(0.5), 'matrix_inv_iterations': array(20.), 'solver_maxls': array(15.), 'spring_inertia_scale': array(1.), 'spring_mass_scale': array(0.), 'vel_damping': array(0.)}



# coordinate systems

## Z (vertical) blue
## Y (horizontal) green
## X (horizontal) blue